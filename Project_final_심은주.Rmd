---
title: "서울시 역세권 청년주택 우선 입지 선정"
author: '2017311868 심은주'
output: html_document
mainfont: nanum
---

<br>

## 01. 서론

### 01) 주제 선정 배경 및 필요성

현 시대의 청년 세대는 최악의 실업률과 열악한 주거환경으로 인해 경제적 빈곤에 시달리며, 많은 것을 비자발적으로 포기해야 하는 'N포 세대'라고도 불린다. 특히, 서울의 가파른 집값 상승으로 인해 내집마련이 인생의 목표가 되어 버린 청년 세대가 서울을 벗어나는 탈서울화가 일어나고 있다. <br>

|청년 실업률| 청년 주거빈곤율|     탈서울인구|
|:----------|---------------:|--------------:|
|9.0%       |           37.2%|           57만|


이를 해결하고자 서울시는 2016년 '역세권 2030 청년주택' 사업을 발표하였고, 2017년을 시작으로 본격적으로 사업을 추진하고 있다. 해당 사업의 목표는 2022년까지 총 8만호를 공급하는 것이었으나, 현재 2022년까지 예정된 공급실 수는 약 1만호 밖에 되지 않는다. <br>
따라서 더 많은 역세권 청년주택이 공급되어야 하는 상황이며, 이는 현재 청년 세대인 본인과도 직결된 주제라고 생각해 역세권 청년주택의 우선 입지 선정을 본 프로젝트의 주제로 선정하였다.

### 02) 분석 목적

- 서울시 관련 빅데이터와 통계적 기법을 활용하여 역세권 청년주택의 필요성이 높은 지역 선정
- 역세권 청년주택의 입지 요건 등을 고려하여 효율적인 주택 공급 방법 제안

## 02. 분석 데이터

```{r packages, include = FALSE}
library(data.table)
library(tidyverse)
library(magrittr)
library(progress)
library(httr) # GET()
library(jsonlite) # fromJSON()
library(ggmap)
library(rgdal)
library(showtext)
library(stats)
library(nsprcomp)
library(psych)
library(GPArotation)
library(cluster)
library(fpc)
library(factoextra)
library(NbClust)
```

```{r, echo = F, include=FALSE}
font_add("nanum", "NanumSquare_acL.ttf")
showtext_auto()
```


```{r setwd, echo=FALSE}
setwd("C:/Users/seses/Desktop/대학/2021-1/대용량자료관리및시각화/Project/data")
```

### 01) 역세권 청년주택 주소 데이터

- 데이터 명: 역세권 청년주택 정보
- 데이터 기간: 2021년 4월 기준
- 데이터 정보: 2021년 공급 예정인 곳을 포함한 역세권 청년주택 이름 및 주소
- 출처: 역세권 청년주택사업 홈페이지

```{r youthhouse1, echo=FALSE}
youthhouse <- readxl::read_excel("youthhouse.xlsx", sheet = 1, col_names = TRUE)
youthhouse %>% head()
```

### 02) 서울시 지하철 주소 데이터

- 데이터 명: 서울교통공사 노선별 지하철역 정보
- 데이터 기간: 2020년 7월 기준
- 데이터 정보: 서울시에 위치한 지하철역의 주소 및 정보
- 출처: 서울교통공사

```{r subway1, echo = FALSE}
subway1 <- fread("서울교통공사 노선별 지하철역 정보.csv")
subway1 %>% head()
```

### 03) 경의중앙선 주소 데이터

- 데이터 명: 국가철도공단 경의중앙선 주소데이터
- 데이터 기간: 2020년 11월 기준
- 데이터 정보: 경의중앙선에 해당하는 역의 주소 및 정보
- 출처: 국가철도공단

```{r  ,echo = FALSE}
gyeong <- fread("국가철도공단_경의중앙선_주소데이터_20201123.csv")
gyeong %>% head()
```

### 04) 경춘선 주소 데이터

- 데이터 명: 국가철도공단 경춘선 주소데이터
- 데이터 기간: 2020년 11월 기준
- 데이터 정보: 경춘선에 해당하는 역의 주소 및 정보
- 출처: 국가철도공단

```{r , echo = FALSE}
chun <- fread("국가철도공단_경춘선_역위치_20201202.csv", encoding = "UTF-8" )
chun %>% head()
```

### 05) 공항철도 주소 데이터

- 데이터 명: 국가철도공단 공항철도 주소데이터
- 데이터 기간: 2020년 11월 기준
- 데이터 정보: 공항철도에 해당하는 역의 주소 및 정보
- 출처: 국가철도공단

```{r , echo = FALSE}
airport <- fread("국가철도공단_공항철도_역위치_20201121.csv", encoding = "UTF-8")
airport %>% head()
```

### 06) 신분당선 주소 데이터

- 데이터 명: 국가철도공단 신분당선 주소데이터
- 데이터 기간: 2020년 11월 기준
- 데이터 정보: 신분당선에 해당하는 역의 주소 및 정보
- 출처: 국가철도공단

```{r , echo = FALSE}
bundang <- fread("국가철도공단_신분당선_역위치_20201121.csv", encoding = "UTF-8")
bundang %>% head()
```

### 07) 우이신설 주소 데이터

- 데이터 명: 국가철도공단 우의신설 주소데이터
- 데이터 기간: 2020년 11월 기준
- 데이터 정보: 우의신설에 해당하는 역의 주소 및 정보
- 출처: 국가철도공단

```{r , echo = FALSE}
ui <- fread("국가철도공단_우이신설_주소데이터_20201123.csv")
ui %>% head()
```

### 08) 서울시 버스정류장 데이터

- 데이터 명: 서울시 버스정류소 좌표 데이터
- 데이터 기간: 2021년 5월 기준
- 데이터 정보: 서울시에 위치한 버스정류소의 위도와 경도를 포함한 데이터
- 출처: 공공데이터포털

```{r , echo = FALSE}
busstation <- fread("서울시버스정류소좌표데이터.csv")
busstation %>% head()
```

### 09) 서울시 대학 및 전문 대학 정보 데이터

- 데이터 명: 서울시 대학 및 전문대학 DB 정보 (수시)
- 데이터 기간: 2016년 2월 기준
- 데이터 정보: 서울 시내 대학 및 전문대학의 종류별 학교명 및 상태, 주소 등 관련 정보 한국어 파일
- 출처: 서울 열린데이터 광장

```{r univ1, echo=FALSE}
univ <- fread("university.csv")
univ %>% head()
```

### 10) 서울시 사업체 정보 데이터

- 데이터 명: 서울시 사업체 현황 (조직형태별/동별) 통계
- 데이터 기간: 2019년 기준
- 데이터 정보: 서울시 사업체 현황을 조직 형태별, 구/동별로 제공하는 지정/조사통계
- 출처: 서울 열린데이터 광장

```{r company1,echo=FALSE}
company <- readxl::read_excel("company.xlsx", sheet = 1, col_names = TRUE)
company %>% head()
```

### 11) 서울시 동별 혼인/이혼 데이터

- 데이터 명: 서울시 혼인이혼 (동별) 통계 (연간)
- 데이터 기간: 2020년 한 해
- 데이터 정보: 서울시 혼인 인구와 이혼 인구현황을 동별로 제공
- 출처: KOSIS 국가통계포털

```{r marriage1, echo=FALSE}
marriage <- readxl::read_excel("marriage.xlsx", sheet = 1, col_names = TRUE)
marriage %>% head()
```

### 12) 서울시 주민등록 청년 인구 데이터

- 데이터 명: 서울시 주민등록인구 (동별/연령별) 통계
- 데이터 기간: 2020년 기준
- 데이터 정보: 서울시 주민등록인구수를 연령별/행정동별로 제공
- 출처: 서울시 통계정보시스템

```{r population1, echo=FALSE}
population <- readxl::read_excel("population.xlsx", sheet = 1, col_names = TRUE, na = '-')
population %>% head()
```

### 13) 서울시 주택 전/월세 실거래가 데이터

- 데이터 명: 전월세 실거래가
- 데이터 기간: 2021년 1월 - 2021년 2월
- 데이터 정보: 2021년 1월부터 2월까지 실제로 거래된 주택 유형별 주소, 가격 등 제공

      - 단독/다가구 주택
      
```{r single.multi1, echo=FALSE}
single.multi <- fread("단독다가구(전월세)_실거래가.csv")
single.multi %>% head()
```
      
      - 연립/다세대 주택
      
```{r coalition1, echo=FALSE}
coalition <- fread("연립다세대(전월세)_실거래가.csv")
coalition %>% head()
```
      
      - 아파트
      
```{r apartment1, echo= FALSE}
apartment <- fread("아파트(전월세)_실거래가.csv")
apartment %>% head()
```
      
      - 오피스텔
      
```{r officetel1, echo=FALSE}
officetel <- fread("오피스텔(전월세)_실거래가.csv")
officetel %>% head()
```
      
- 출처: 국토교통부 실거래가 공개시스템

### 14) 전월세전환율 데이터

- 데이터 명: 전국 주택가격 동향 조사: 전월세전환율
- 데이터 기간: 2021년 1월 - 2021년 2월
- 데이터 정보: 월 단위로 기록된 주택유형별 전국 전월세전환율 데이터

      - 규모별: 규모1(30$m^2$ 이하), 규모2(30$m^2$ 초과 60$m^2$ 이하), 규모3(60$m^2$ 초과)
      
```{r juntowol_scale1,echo=FALSE}
juntowol_scale <- fread("규모별_전월세전환율.csv")
juntowol_scale %>% head()
```
      
      - 지역별: 아파트의 경우, 행정구 단위로 제공
      
```{r juntowol_area1, echo=FALSE}
juntowol_area <- fread("지역별_전월세전환율.csv")
juntowol_area %>% head()
```
      
- 출처: KOSIS 국가통계포털

### 15) 전국 행정동 경계 데이터

- 데이터 명: 행정동경계
- 데이터 기간: 2021년 3월 기준
- 데이터 정보: 전국 행정동 경계 공간 데이터
- 출처: 국토교통부 국가공간정보포털

```{r map, echo=FALSE, message = FALSE}
map = readOGR('Z_SOP_BND_ADM_DONG_PG.shp')
```

### 16) 전국 행정동코드 데이터

- 데이터 명: 행정동코드 매핑데이터
- 데이터 기간: 2018년 기준
- 데이터 정보: 전국 통계청 행정동코드, 행정안전부 행정동코드, 행정동 등에 대한 데이터
- 출처: 서울 열린데이터 광장

```{r dong_code1, echo=FALSE}
dong_code <- readxl::read_excel("행정동코드_매핑정보_2018.xlsx", sheet = 1, col_names = T)
dong_code %>% head()
```

## 03. 변수 생성

### 1) 역세권 청년주택

역세권 청년주택 데이터에 있는 지번주소에서 행정동을 추출하기 위해 카카오 API를 사용하였다.

```{r API key, echo=FALSE}
# Web API key
KAKAO_MAP_API_KEY = "###"
```

```{r }
# 검색할 주소 목록
address_list <- youthhouse$address



# 결과 저장용 데이터프레임
bowl1 = data.frame(address = address_list,
                   gu = rep(NA, length(address_list)),
                  dong = rep(NA, length(address_list)),
                  long = rep(NA, length(address_list)),
                  lat = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  gu <- coord$documents$address$region_2depth_name
  dong <- coord$documents$address$region_3depth_h_name
  
  if (length(dong) > 0) {
    # 검색 결과가 없는 경우
    bowl1$gu[i] <- gu
    bowl1$dong[i] <- dong
    bowl1$long[i] <- as.double(coord$documents$x)
    bowl1$lat[i] <- as.double(coord$documents$y)
  } else {      # 검색되지 않는 주소는 NA로 처리
    bowl1$gu[i] <- NA
    bowl1$dong[i] <- NA
    bowl1$long[i] <- NA
    bowl1$lat[i] <- NA
  }
}
```

주소를 이용해 행정동과 위도, 경도 데이터를 수집하였다. 수집한 데이터는 다음과 같다.

```{r bowl1,echo=FALSE}
bowl1 %>% head()
```

이렇게 수집한 데이터를 'address'를 기준으로 기존의 'youthhouse'데이터와 합쳐주었다. 

```{r}
# youthhouse 데이터와 합쳐주기
youthhouse %<>% left_join(bowl1, by = "address") %>% 
  select(-c(address))

# NA 확인
colSums(is.na(youthhouse))
```

NA를 확인해보니 하나의 행이 NA인 것을 알 수 있다. 해당 주소에 대해서는 직접 수기로 입력해주었다.

```{r}
youthhouse[11, 2:5] <- list("마포구", "서교동", 126.9145769, 37.5507547)
```

현재 존재하는 역세권 청년주택의 위치를 시각화해보았다. <br>
우선 행정동 단위의 지도를 보여주는 shapefile을 가져와 좌표계를 변경해준 후, 서울 지역만 추출하였다.

```{r}
# 행정동 단위 지도 불러오기
map = readOGR('Z_SOP_BND_ADM_DONG_PG.shp')

# 좌표계 변환
proj4string(map) <- CRS('+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=bessel +units=m')
to_crs = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
map = spTransform(map, to_crs)
new_map = fortify(map, region = "ADM_DR_CD")
new_map$id = as.numeric(new_map$id)

# 서울에 해당하는 지역만 추출
seoul_map = new_map[new_map$id <= 1174099,]
```

```{r , include = FALSE, echo = F}
options(scipen=999)
```

2021년 기준 존재하는 역세권 청년주택의 위치는 다음과 같다.

```{r}
ggplot(youthhouse, aes(x = long, y = lat)) + 
  geom_polygon(data = seoul_map, aes(x = long, y = lat, group = group),
               fill = "grey", color = 'lightgrey', alpha = 0.2) +
  geom_point(color = "#14B9B7", alpha = 0.55, aes(), size = 3) +
  ggtitle('현재 역세권 청년주택의 위치') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = "")
```

우선 역세권 청년주택이 존재하는 행정동이 많지 않기 때문에 조금 더 다양한 행정동에 역세권 청년주택이 공급되어야 할 필요가 있다고 보인다. 눈에 띄는 점은 가장 많은 역세권 청년주택이 존재하는 행정동이 **'서강동'**이라는 것인데, 특히 바로 인접한 '서교동'에도 역세권 청년주택이 존재한다. '서강동'과 '서교동'은 주변에 홍익대, 연세대, 서강대 등 많은 대학교가 존재하는 행정동으로 이 때문에 역세권 청년주택이 밀집되어 있는 것으로 생각된다. 

### 2) 서울시 내에 존재하는 지하철 및 기차역

지하철역 데이터의 경우, 먼저 역명을 이용해 위도와 좌표를 추출한 뒤, 이 좌표를 이용해 행정동을 추출하였다. <br>
하지만 데이터의 전철역명에서 '서울역'과 같이 '역'이 포함되어 있는 역명이 있는 반면, '홍대입구'와 같이 '역'이 제외된 역명이 있기 때문에, 해당 값이 '역'이라는 문자를 포함하고 있지 않는 경우 뒤에 '역'을 붙여주어 카카오 API 검색이 용이하게 하였다. 

```{r}
subway1$`전철역명` <- ifelse(str_detect(subway1$`전철역명`, "역"), subway1$`전철역명`, paste0(subway1$`전철역명`,"역"))
```

```{r}
#
address_list <- subway1$`전철역명`

# 결과 저장용 데이터프레임

bowl2 = data.frame(address = address_list,
                   gu = rep(NA, length(address_list)),
                   dong = rep(NA, length(address_list)),
                   x = rep(NA, length(address_list)),
                   y = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){
  
  # 키워드를 이용한 검색
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/keyword.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  for (j in 1:length(coord$documents$category_group_name)) {
    
    # 지하철역의 카테고리에 해당할 경우, 위도와 경도 저장
    if (coord$documents$category_group_name[j] == "지하철역"){
      bowl2$x[i] = coord$documents$x[j]
      bowl2$y[i] = coord$documents$y[j]
      X = coord$documents$x[j]
      Y = coord$documents$y[j]
      
      # 위도와 경도 좌표를 이용한 검색
      res1 <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
                 query = list(x = X, y = Y),
                 add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
      coord1 <- res1 %>% content(as = 'text') %>% fromJSON()
      
      dong <- coord1$documents$region_3depth_name[2]
      gu <- coord1$documents$region_2depth_name[2]
      
      if (length(dong) > 0){
        bowl2$gu[i] <- gu
        bowl2$dong[i] <- dong
      } else {
        bowl2$gu[i] <- NA
        bowl2$dong[i] <- NA
      }
      break
    } else next
  }
}

```

완성된 행정동 및 위,경도 좌표 추출 데이터를 기존의 'subway1' 데이터와 역명을 기준으로 합쳐주었다.

```{r}
subway1 %<>% left_join(bowl2, by = c("전철역명" = "address")) %>% 
  select(전철역명, 호선, gu, dong, x, y)
```

카카오 API를 이용해 수집한 결과를 보니, '역삼역'의 경우 '역삼'에 '역'이라는 문자가 포함되어 '역삼역'이 아닌 '역삼'으로 검색되었다. 이에 따라 키워드의 카테고리가 '지하철역'에 해당되지 않아 NA값을 갖게 되어 직접 채워주었다. 

```{r}
subway1[is.na(subway1$dong),3:6] <- list("강남구", "역삼1동", 127.0368054, 37.5007231) 
```

자치구와 행정동을 기준으로 행정동별 지하철역의 수를 계산하였다.

```{r}
subway1 <- subway1 %>% group_by(gu, dong) %>% 
  summarise(subway = n())
```

후의 과정에서도 계속해서 등장하겠지만, 서울시 행정동 중 **"신사동"**은 총 '관악구'와 '강남구' **두 곳에 존재**한다. 따라서 앞으로의 데이터 분석 과정에서 차질을 빚지 않도록 두 행정동의 이름을 구분짓기로 한다. <br>
'강남구'의 신사동의 '신사동_강', '관악구'의 신사동은 '신사동_관'이라는 명칭으로 변경한다.

```{r}
subway1[subway1$gu == "관악구" & subway1$dong == "신사동", "dong"] <- "신사동_관"
subway1[subway1$gu == "강남구" & subway1$dong == "신사동", "dong"] <- "신사동_강"
```

행정동별로 정리된 데이터를 확인하니 서울시에 해당하지 않는 지역들이 포함되어 있었다. 자치구의 unique 값을 확인해 서울시가 아닌 지역은 삭제해주었다. 

```{r}
subway1 %<>% filter(gu != "고양시 덕양구", gu != "광명시", gu != "부천시", gu != "부평구",
                   gu != "성남시 수정구", gu != "성남시 중원구", gu != "의정부시", gu != "하남시")
```

<br>
다음으로, 지하철역 이외에 서울시에 존재하는 기차역 역시 고려하고자 하였다. 수도권의 전철 노선 중 서울시에 역이 존재하는 노선에는 경의중앙선, 경춘선, 공항철도, 신분당선, 우이신설이 있다.  <br>

먼저, 경의중앙선의 역 중에서 도로명주소를 기반으로 서울에 위치한 역만 추출하였다.

```{r}
gyeong %<>% filter(str_detect(도로명주소, "서울특별시"))
```

그리고 카카오 API를 이용해 도로명주소로 행정동과 위, 경도 좌표를 추출하였다.

```{r}
gyeong %<>% select(선명, 역명, 도로명주소)

address_list <- gyeong$도로명주소

bowl8 = data.frame(address = address_list,
                   gu = rep(NA, length(address_list)),
                   dong = rep(NA, length(address_list)),
                   x = rep(NA, length(address_list)),
                   y = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  gu <- coord$documents$address$region_2depth_name
  dong <- coord$documents$address$region_3depth_h_name
  
  if (length(dong) > 0) {
    bowl8$gu[i] <- gu
    bowl8$dong[i] <- dong
    bowl8$x[i] = coord$documents$x[j]
    bowl8$y[i] = coord$documents$y[j]
  } else {
    bowl8$gu[i] <- NA
    bowl8$dong[i] <- NA
    bowl8$x[i] <- NA
    bowl8$y[i] <- NA
  }
}

```

앞서 한 방법과 마찬가지로 도로명주소를 기준으로 기존의 경의중앙선 데이터와 합쳐주었고, 이를 자치구 및 행정동을 기준으로 묶어 행정동별 경의중앙선의 역 개수를 구하였다.

```{r}
gyeong %<>% left_join(bowl8, by = c("도로명주소" = "address"))

gyeong %<>% group_by(gu, dong) %>% summarise(경의선 = n())
```

경춘선의 경우, 데이터가 위도와 경도 좌표를 포함하고 있었기 때문에 이를 이용해 카카오 API로 행정동을 찾아주었다. 

```{r}
chun %<>% select(-c(철도운영기관명)) 

address_list = list(chun$경도, chun$위도)

bowl9 <- data.frame(X = address_list[[1]], Y = address_list[[2]],
                    gu = rep(NA, length(address_list[[1]])),
                    dong = rep(NA, length(address_list[[1]])))

for (i in 1:length(address_list[[1]])){
  
  # 위도와 경도 좌표를 이용해 검색
  res <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
             query = list(x = address_list[[1]][i], y = address_list[[2]][i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  dong <- coord$documents$region_3depth_name[2]
  gu <- coord$documents$region_2depth_name[2]
  
  if (length(dong) > 0){
    bowl9$gu[i] <- gu
    bowl9$dong[i] <- dong
  } else {
    bowl9$gu[i] <- NA
    bowl9$dong[i] <- NA
  }
}

chun %<>% cbind(bowl9) %>% select(-c(X , Y))

# 자치구 및 행정동을 기준으로 행정동별 역의 개수 계산
chun %<>% group_by(gu, dong) %>% summarise(경춘선 = n())
```

공항철도와 신분당선 역시 같은 방법으로 데이터를 전처리하였다.

```{r}
## 공항철도

airport %<>% select(-c(철도운영기관명))

address_list = list(airport$경도, airport$위도)

bowl10 <- data.frame(X = address_list[[1]], Y = address_list[[2]],
                    gu = rep(NA, length(address_list[[1]])),
                    dong = rep(NA, length(address_list[[1]])))

for (i in 1:length(address_list[[1]])){
  
  #위도와 경도 좌표를 이용해 검색
  res <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
             query = list(x = address_list[[1]][i], y = address_list[[2]][i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  dong <- coord$documents$region_3depth_name[2]
  gu <- coord$documents$region_2depth_name[2]
  
  if (length(dong) > 0){
    bowl10$gu[i] <- gu
    bowl10$dong[i] <- dong
  } else {
    bowl10$gu[i] <- NA
    bowl10$dong[i] <- NA
  }
}

airport %<>% cbind(bowl10) %>% select(-c(X , Y))

# 서울지역만 추출
airport <- airport[1:5,] 

# 자치구 및 행정동을 기준으로 행정동별 역의 개수 계산
airport %<>% group_by(gu, dong) %>% summarise(공항철도 = n())


## 신분당선
bundang %<>% select(-c(철도운영기관명)) 

address_list = list(bundang$경도, bundang$위도)

bowl11 <- data.frame(X = address_list[[1]], Y = address_list[[2]],
                    gu = rep(NA, length(address_list[[1]])),
                    dong = rep(NA, length(address_list[[1]])))

for (i in 1:length(address_list[[1]])){
  
  # 위도와 경도 좌표를 이용해 검색
  res <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
             query = list(x = address_list[[1]][i], y = address_list[[2]][i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  dong <- coord$documents$region_3depth_name[2]
  gu <- coord$documents$region_2depth_name[2]
  
  if (length(dong) > 0){
    bowl11$gu[i] <- gu
    bowl11$dong[i] <- dong
  } else {
    bowl11$gu[i] <- NA
    bowl11$dong[i] <- NA
  }
}

bundang %<>% cbind(bowl11) %>% select(-c(X , Y))

# 서울지역만 추출
bundang <- bundang[1:4, ] 

# 자치구 및 행정동을 기준으로 행정동별 역의 개수 계산
bundang %<>% group_by(gu, dong) %>% summarise(신분당선 = n())
```

우이신설의 경우, 경의중앙선과 마찬가지로 위도와 경도 좌표가 존재하지 않았기 때문에 도로명주소를 이용해 행정동을 찾아주었다.

```{r}
ui %<>% select(선명, 역명, 도로명주소)

address_list <- ui$도로명주소

bowl12 = data.frame(address = address_list,
                   gu = rep(NA, length(address_list)),
                   dong = rep(NA, length(address_list)),
                   x = rep(NA, length(address_list)),
                   y = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:5){
  
  # 도로명주소를 이용해 검색
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  gu <- coord$documents$address$region_2depth_name
  dong <- coord$documents$address$region_3depth_h_name
  
  if (length(dong) > 0) {
    bowl12$gu[i] <- gu
    bowl12$dong[i] <- dong
    bowl12$x[i] = coord$documents$x[j]
    bowl12$y[i] = coord$documents$y[j]
  } else {
    bowl12$gu[i] <- NA
    bowl12$dong[i] <- NA
    bowl12$x[i] <- NA
    bowl12$y[i] <- NA
  }
}

for(i in 7:length(address_list)){
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  gu <- coord$documents$address$region_2depth_name
  dong <- coord$documents$address$region_3depth_h_name
  
  if (length(dong) > 0) {
    bowl12$gu[i] <- gu
    bowl12$dong[i] <- dong
    bowl12$x[i] = coord$documents$x[j]
    bowl12$y[i] = coord$documents$y[j]
  } else {
    bowl12$gu[i] <- NA
    bowl12$dong[i] <- NA
    bowl12$x[i] <- NA
    bowl12$y[i] <- NA
  }
}

ui %<>% left_join(bowl12, by = c("도로명주소" = "address"))
```

NA를 확인해본 결과, '삼양역'의 정보를 찾을 수 없었고 이는 직접 수기로 입력하였다.

```{r}
ui[6, 6:9] <- list("강북구", "삼양동", 127.0181540, 37.6266863)
```

마지막으로 자치구 및 행정동을 기준으로 행정동별 역의 개수를 계산하였다.

```{r}
ui %<>% group_by(gu, dong) %>% summarise(우이신설 = n())
```

이렇게 전처리한 서울 내의 모든 역 데이터를 하나로 합쳐주었다. 

```{r}
subway1 %<>% full_join(airport, by = c("gu", "dong")) %>% 
  full_join(bundang, by = c("gu", "dong")) %>% 
  full_join(chun, by = c("gu", "dong")) %>% 
  full_join(gyeong, by = c("gu", "dong")) %>% 
  full_join(ui, by = c("gu", "dong"))
```

행정동별로 NA인 곳에는 역이 존재하지 않는 것이기 때문에 0을 대입해주었다. 또한 모든 전철역의 수를 합쳐 하나의 '전철역'이라는 변수로 만들어주었다.

```{r}
# NA 대체
subway1[is.na(subway1$subway), "subway"] <- 0
subway1[is.na(subway1$공항철도), "공항철도"] <- 0
subway1[is.na(subway1$경의선), "경의선"] <- 0
subway1[is.na(subway1$신분당선), "신분당선"] <- 0
subway1[is.na(subway1$경춘선), "경춘선"] <- 0
subway1[is.na(subway1$우이신설), "우이신설"] <- 0

# 하나의 변수로 더해서 계산
subway1 %<>% mutate(전철역 = subway + 공항철도 + 경의선 + 신분당선 + 경춘선 + 우이신설) %>% 
  select(gu, dong, 전철역)
```

행정동별 전철역의 수를 시각화하고자 먼저 행정동 코드 데이터를 정제하였다.

```{r}
## 필요한 열만 추출
dong_code %<>% select(-c(행자부행정동코드)) %>% 
  filter(시도명 == "서울") %>% 
  drop_na() %>% 
  select(-c(시도명))

## 신사동 행정동명 변경
dong_code[dong_code$시군구명 == "관악구" & dong_code$행정동명 == "신사동", "행정동명"] <- "신사동_관"
dong_code[dong_code$시군구명 == "강남구" & dong_code$행정동명 == "신사동", "행정동명"] <- "신사동_강"
```

정제된 행정동 코드 데이터를 이용해 지도 데이터와 결합 후 시각화하였다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(subway1, by = c("시군구명" = "gu", "행정동명" = "dong")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$전철역), "전철역"] <- 0
mapping$행정동코드 %<>% as.numeric()
subway_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))

## plot
ggplot() + 
  geom_polygon(data = subway_map, aes(x = long, y = lat, group = group, fill = 전철역), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#965A9D") + ggtitle('지하철역') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

중간보고서에서 나아가 1~9호선 지하철역 뿐만 아니라 경의선, 우이신설과 같은 전철역도 모두 고려하였다. 또한 각 호선 별 모든 역을 고려함으로써 환승역이 존재한다면 환승역의 수만큼 카운트 되었기 때문에, 이후에 입지선정 과정에서 더 높은 가중치를 받게 되었다. 


### 3) 행정동별 버스정류장 수

버스정류장 데이터의 경우 위도와 경도 좌표가 존재하기 때문에, 카카오 API를 이용해 행정동을 추출하였다. 

```{r}
address_list = list(busstation$X좌표, busstation$Y좌표)

bowl7 <- data.frame(X = address_list[[1]], Y = address_list[[2]],
                      gu = rep(NA, length(address_list[[1]])),
                      dong = rep(NA, length(address_list[[1]])))


pb <- progress_bar$new(total = length(address_list[[1]]))

for (i in 1:length(address_list[[1]])){
  pb$tick()
  Sys.sleep(0.01)
  
  res <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
             query = list(x = address_list[[1]][i], y = address_list[[2]][i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  dong <- coord$documents$region_3depth_name[2]
  gu <- coord$documents$region_2depth_name[2]
  
  if (length(dong) > 0){
    bowl7$gu[i] <- gu
    bowl7$dong[i] <- dong
  } else {
    bowl7$gu[i] <- NA
    bowl7$dong[i] <- NA
  }
}

## 기존 데이터와 합치기
busstation %<>% cbind(bowl7) %>% 
  select(-c(X, Y)) %>% 
  rename(자치구 = gu, 행정동 = dong)
```

1개의 NA가 존재해 해당 행만 뽑아 다시 한 번 카카오 API를 실행하였다.

```{r}
res <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
           query = list(x = busstation[10921,4], y = busstation[10921,5]),
           add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
coord <- res %>% content(as = 'text') %>% fromJSON()

dong <- coord$documents$region_3depth_name[2]
gu <- coord$documents$region_2depth_name[2]

busstation[10921,6] <- gu
busstation[10921,7] <- dong
```

마찬가지로 '신사동'의 명칭을 변경해주었고, 행정동별 버스정류장의 수를 계산하였다.

```{r}
## 신사동 이름 변경
busstation[busstation$자치구 == "관악구" & busstation$행정동 == "신사동", "행정동"] <- "신사동_관"
busstation[busstation$자치구 == "강남구" & busstation$행정동 == "신사동", "행정동"] <- "신사동_강"

## 행정동별 버스정류장의 수 계산
busstation %<>% group_by(자치구, 행정동) %>% 
  summarise(bus_station = n())
```

자치구와 행정동의 unique 값을 보니 서울시가 아닌 위치가 존재해 이를 삭제해주었다.

```{r}
busstation$자치구 %>% unique() # 안양시 만안구, 양주시, 성남시 수정구, 하남시 존재

busstation %<>% filter(자치구 != "성남시 수정구", 자치구 != "양주시", 자치구 != "안양시 만안구", 
                         자치구 != "하남시", 자치구 != "광명시", 자치구 != "과천시")

busstation$행정동 %>% unique()  # 인천시 중구 영종동 존재
busstation %<>% filter(행정동 != "영종동")
```

완성된 데이터를 시각화해보면 다음과 같다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(busstation, by = c("시군구명" = "자치구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$bus_station), "bus_station"] <- 0
mapping$행정동코드 %<>% as.numeric()
bus_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))


## plot
ggplot() + 
  geom_polygon(data = bus_map, aes(x = long, y = lat, group = group, fill = bus_station), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#14B9B7") + ggtitle('버스정류장') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

전철역과 다르게 버스정류장의 경우, 서울 외곽 지역에 더 많이 분포해 있는 것을 알 수 있다. 

### 4) 교통밀접도 변수

전철과 버스정류장의 수를 합쳐 '교통밀접도'라는 변수를 만들고자 한다. 역세권 청년주택은 반드시 역세권에 존재해야 하지만, 꼭 전철이 아니더라도 버스를 타고 등교 또는 통근하는 사람들이 많기 때문에 교통밀접도는 공공주택의 입지를 선정할 때 중요한 요소라고 할 수 있다. 

```{r}
## 행정동명에 차이가 있는지 확인
subway1$dong %>% setdiff(busstation$행정동) # 없음
busstation$행정동 %>% setdiff(subway1$dong)

## 버스정류장 기준으로 합치기
traffic_closure <- busstation %>% left_join(subway1, by = c("자치구" = "gu", "행정동" = "dong"))
```

NA는 해당 행정동에 전철역이 존재하지 않는다는 의미이기 때문에 0으로 대체하였다.

```{r}
traffic_closure[is.na(traffic_closure$전철역), "전철역"] <- 0
```

또한 전철역이 존재하지 않는 행정동은 후에 입지 행정동을 선정할 때 필요하기 때문에 따로 추출하였다.

```{r}
no_subway <- traffic_closure %>% filter(전철역 == 0)
```

최종적으로 행정동별 버스정류장의 수와 전철역의 수를 합쳐 '교통밀접도'라는 변수를 생성하였고, 이를 시각화하면 다음과 같다.

```{r}
traffic_closure %<>% mutate(교통밀접도 = bus_station + 전철역) %>% select(자치구, 행정동, 교통밀접도)
```

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(traffic_closure, by = c("시군구명" = "자치구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$교통밀접도), "교통밀접도"] <- 0
mapping$행정동코드 %<>% as.numeric()
traffic_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))


## plot
ggplot() + 
  geom_polygon(data = traffic_map, aes(x = long, y = lat, group = group, fill = 교통밀접도), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#965A9D") + ggtitle('교통밀접도') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

버스정류장과 전철역 중 버스정류장의 단위가 월등히 크기 때문에, 교통밀접도 자체가 버스정류장의 수와 매우 비슷한 양상을 보인다. 하지만 전철역의 경우, 뒤에서 또 고려하기 때문에 문제가 없다고 판단하였다.

### 5) 행정동별 대학교 수

대학교 데이터의 경우 행정구와 행정동이 모두 존재하기 때문에, 다른 전처리 과정 없이 행정구와 행정동 기준으로 대학교의 수를 산출하였다.

```{r univ2}
univ %<>% select(학교명, 행정구, 행정동) %>%
  group_by(행정구, 행정동) %>%
  summarise('대학 수' = n())     #행정동별 대학 개수
```

완성된 데이터를 시각화하면 다음과 같다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(univ, by = c("시군구명" = "행정구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$`대학 수`), "대학 수"] <- 0
mapping$행정동코드 %<>% as.numeric()
univ_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))

## plot
ggplot() + 
  geom_polygon(data = univ_map, aes(x = long, y = lat, group = group, fill = `대학 수`), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#14B9B7") + ggtitle('대학교 수') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

앞서 언급했듯 대학교가 많은 행정동 주변에 역세권 청년주택이 존재한다. 즉, 현재 존재하는 역세권 청년주택은 대학교에 초점을 맞춘 것으로 보인다. 하지만 위의 시각화자료에서도 알 수 있듯, 한 행정동에 대학교는 최대 2개가 존재하고 한 개의 대학교도 존재하지 않는 행정동이 대부분이다. 뒤의 과정에서, 이 부분을 고려해야 할 것으로 보인다.

### 6) 행정동별 사업체 및 종사자의 수

사업체 데이터 역시 행정구와 행정동이 모두 존재하기 때문에, 필요한 변수만 남긴 후 자치구와 행정동을 기준으로 사업체 수, 종사자 수를 산출하였다.

```{r}
company %<>% select(자치구, 동, `사업체수 계`, `종사자수 계`) %>%
  filter(동 != '합계' & 동 != '소계') %>%     # 행정동 별 합계를 나타내는 row 삭제
  rename(행정구 = 자치구, 행정동 = 동, 사업체수 = `사업체수 계`, 종사자수 = `종사자수 계`)    
  #'행정구'와 '행정동'으로 변수명 통일
```

또한 앞서 언급한 바와 같이 '신사동'의 명칭을 변경해주었다.

```{r}
company[company$행정구 == "관악구" & company$행정동 == "신사동", "행정동"] <- "신사동_관"
company[company$행정구 == "강남구" & company$행정동 == "신사동", "행정동"] <- "신사동_강"
```

완성된 데이터를 시각화하면 다음과 같다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(company, by = c("시군구명" = "행정구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$`사업체수`), "사업체수"] <- 0
mapping[is.na(mapping$종사자수), "종사자수"] <- 0
mapping$행정동코드 %<>% as.numeric()
company_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))

## 사업체수 plot
ggplot() + 
  geom_polygon(data = company_map, aes(x = long, y = lat, group = group, fill = 사업체수), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#965A9D") + ggtitle('사업체 수') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")

## 종사자수 plot
ggplot() + 
  geom_polygon(data = map_data, aes(x = long, y = lat, group = group, fill = 종사자수), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#14B9B7") + ggtitle('종사자 수') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

사업체의 경우, 도심권과 동남권에 가장 많이 분포되어 있다. 이는 역세권 청년주택의 위치와 불일치하는 양상으로, 앞서 말했듯 현재 존재하는 역세권 청년주택은 직장보다는 대학에 더 초점을 맞춘 것으로 보인다. <br>
종사자수는 사업체수와 거의 동일한 양상을 띄고 있어, 두 변수의 상관관계가 매우 높을 것이라고 예상할 수 있다.


### 7) 행정동별 신혼부부 수

혼인/이혼 데이터에서 혼인 변수를 이용해 신혼부부의 수를 대체하고자 하였다. 데이터에 자치구와 행정동이 존재하기 때문에 필요한 변수만 추출하는 방식까지의 전처리만 진행하였다.

```{r}
marriage %<>% select(자치구, 동, 혼인) %>% 
  filter(동 != '합계' & 동 != '소계') %>%  # 합계를 나타내는 행 삭제
  rename(행정구 = 자치구, 행정동 = 동)     # 변수 이름 통일
```

마찬가지로 '신사동'의 명칭 역시 변경해주었다.

```{r}
marriage[marriage$행정구 == "관악구" & marriage$행정동 == "신사동", "행정동"] <- "신사동_관"
marriage[marriage$행정구 == "강남구" & marriage$행정동 == "신사동", "행정동"] <- "신사동_강"
```

완성된 데이터를 시각화하면 다음과 같다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(marriage, by = c("시군구명" = "행정구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$혼인), "혼인"] <- 0
mapping$행정동코드 %<>% as.numeric()
marriage_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))

## plot
ggplot() + 
  geom_polygon(data = marriage_map, aes(x = long, y = lat, group = group, fill = 혼인), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#965A9D") + ggtitle('신혼부부 수') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

신혼부부, 즉 혼인 인구 같은 경우에는 서울 중심부보다는 서울 외곽 지역에 더 많은 것을 알 수 있다. 이는 서울 중심부의 높은 집값 부담 때문인 것으로 해석할 수 있다. 이 변수의 경우, 행정동의 전체 인구 수에 영향을 받을 수 밖에 없지만 입지를 선정할 때 수요의 절대적인 수를 고려해야한다고 판단해 혼인 인구 수 그대로 사용하기로 하였다.

### 8) 행정동별 청년 인구수

연령 별 주민등록 인구가 나타나 있는 데이터에서 청년 세대에 속하는 연령대만 추출하여 행정동 별 청년 인구를 구하고자 하였다. 

```{r}
population %<>% filter(구분 == '한국인') %>%     # 주민등록 인구 중 한국인만 추출
  select(자치구, 동, `20~24세`, `25~29세`, `30~34세`, `35~39세`) %>% 
  # 역세권 청년주택 입주자 조건: 만 19세~ 39세 청년
  filter(동 != '합계' & 동 != '소계') %>% 
  rename(행정구 = 자치구, 행정동 = 동) %>% 
  mutate(청년인구 = `20~24세` + `25~29세` + `30~34세` + `35~39세`)   
  #20세~39세를 모두 합친 청년 인구 변수 생성
```

'신사동' 명칭 역시 변경해주었다.

```{r}
population[population$행정구 == "관악구" & population$행정동 == "신사동", "행정동"] <- "신사동_관"
population[population$행정구 == "강남구" & population$행정동 == "신사동", "행정동"] <- "신사동_강"
```

완성된 데이터를 시각화하면 다음과 같다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(population, by = c("시군구명" = "행정구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$청년인구), "청년인구"] <- 0
mapping$행정동코드 %<>% as.numeric()
youth_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))

## plot
ggplot() + 
  geom_polygon(data = youth_map, aes(x = long, y = lat, group = group, fill = 청년인구), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#14B9B7") + ggtitle('청년인구') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

청년인구의 분포는 신혼부부의 분포와 유사한 양상을 띈다. 이는 신혼부부에서 20-30대, 즉 청년 인구가 차지하는 비중이 크기 때문인 것으로 보인다. 신혼 부부 변수와 마찬가지로 전체 인구 수에 영향을 받을 수 밖에 없지만 수요의 절대적인 양을 고려하고자 청년 인구수 그대로 사용하였다.

### 09) 주택 유형별 전월세 실거래 데이터

단독/다가구 주택, 연립/다세대 주택, 아파트, 오피스텔 총 4가지 주택 유형에 대해 실거래 데이터를 사용하였다. 각 데이터에 대해 동일한 전처리 과정을 진행하였다. <br>
역세권 청년주택의 경우, 집의 크기가 16-39$m^2$이기 때문에 해당 크기의 거래에 대해서만 분석을 진행하였다. 또한 역세권 청년주택은 월세의 형태이기 때문에 데이터 중 월세 거래만 이용하였다. 다만 월세의 경우, 보증금에 따라 월세가 달라지기 때문에 이 둘을 한 번에 고려하고자 **'완전월세액'**을 사용하기로 하였다. '완전월세액'이란 $월세보증금 * 평균\ 전월세전환율(전월세전환율 / 12) + 월세$를 말한다. 계산을 위해 동일한 시기에 대한 주택 유형별 전월세전환율 데이터를 사용하였다.

#### - 단독/다가구 주택 전/월세 거래 데이터 

```{r}
single.multi %<>% filter(`계약면적(㎡)` < 40.00, 도로명 != 'null', 전월세구분 == '월세') %>% 
  # 역세권 청년주택은 보통 16-39 제곱미터의 크기
  # 도로명 주소가 없다면 정확한 행정동 알 수 없기 때문에 삭제
  select(도로명, 시군구, `보증금(만원)`, `월세(만원)`) %>% 
  # 시군구 변수에서 행정구만 추출하여, 도로명 변수와 합쳐 더 상세한 도로명 주소를 생성함
  mutate(행정구 = str_replace(시군구, '(\\w+[시]) (\\w+[구]) (\\w+[동]|\\w+[동]\\w[가]|\\w+[로]\\w[가]|\\w+[가])','\\2'),
            행정구 = str_replace(행정구, '\\d[가]', ""),
            도로명 = paste0(행정구," ", 도로명))
```

카카오 API를 이용해 도로명 주소에서 행정동을 추출하였다.

```{r}
# 검색할 주소 목록
address_list <- single.multi$도로명

# 결과 저장용 데이터프레임

bowl3 = data.frame(address = address_list,
                   gu = rep(NA, length(address_list)),
                  dong = rep(NA, length(address_list)),
                  long = rep(NA, length(address_list)),
                  lat = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){

  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  if (length(coord$documents$address_type[1]) == 0) {
    # 검색 결과가 없는 경우
    bowl3$gu[i] <- NA
    bowl3$dong[i] <- NA
    bowl3$long[i] <- NA
    bowl3$lat[i] <- NA
  } else {
    # 명확한 위치가 아니기 때문에 위도와 경도를 이용해 행정동을 역추적함
    long <- coord$documents$x[1]
    lat <- coord$documents$y[1]
    
    res1 <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
             query = list(x = long, y = lat),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
    
    coord1 <- res1 %>% content(as = 'text') %>% fromJSON()
    
    bowl3$gu[i] <- coord1$documents$region_2depth_name[2]
    bowl3$dong[i] <- coord1$documents$region_3depth_name[2]
    bowl3$long[i] <- coord1$documents$x[2]
    bowl3$lat[i] <- coord1$documents$y[2]
  }
}
```

수집한 데이터를 기존의 single.multi 데이터와 합쳐주었으며, 위에서 발생한 결측치의 경우 직접 대체하는 것이 어렵다고 생각해 삭제해주었다.

```{r}
single.multi %<>% cbind(bowl3) %>% 
  select(-c(도로명, address, 시군구)) %>% 
  drop_na() %>%  # NA는 직접 채우는 게 어렵다고 판단해 삭제
  mutate(`보증금(만원)` = as.integer(gsub(",","",`보증금(만원)`,fixed=TRUE)))
  # 보증금의 데이터 타입을 integer로 변환
```

다음으로 완전월세액을 계산하기 위해 전월세전환율 데이터를 전처리해주었다. <br>
서울 지역의 2021년 1월부터 2월까지의 데이터만 사용하였으며, 주택 규모의 경우 대부분이 30$m^2$ 이하이기 대문에 '규모1'만 사용하였다.

```{r}
juntowol_scale %<>% filter(`지역별(1)` == '서울', `지역별(3)` != '소계', `주택규모별(1)` == '규모1') %>%
  select(-c(`지역별(1)`,`지역별(2)`, `2020. 09`, `2020. 10`, `2020. 11`, `2020. 12`, `주택규모별(1)`)) %>% 
   mutate(전월세전환율 = (`2021. 01` + `2021. 02`)/2) %>% 
   select(-c(`2021. 01`, `2021. 02`)) %>% 
   rename(주택유형 = `주택유형별(1)`, 지역 = `지역별(3)`)
```

이 때 지역이 도심권, 동북권, 서북권, 서남권, 동남권 5개로 구분되어 있는데, 이에 대한 주석 정보를 가져와 각 권역에 속하는 행정구에는 같은 값을 사용하였다.

```{r}
도심권 <- c('종로구','중구','용산구')
동북권 <- c('성동구', '광진구', '동대문구', '중랑구', '성북구', '강북구', '도봉구', '노원구')
서북권 <- c('은평구', '서대문구', '마포구')
서남권 <- c('양천구', '강서구', '구로구', '금천구', '영등포구', '동작구', '관악구')
동남권 <- c('서초구', '강남구', '송파구', '강동구')

# 단독/다가구 주택의 전월세전환율
juntowol.SM <- juntowol_scale %>% filter(주택유형 == '단독주택')

# 각 권역에 속하는 행정구에는 같은 값 사용
single.multi %<>% mutate(전월세전환율 = ifelse(행정구 %in% 도심권, as.numeric(juntowol.SM[1,3]), 
                                           ifelse(행정구 %in% 동북권, as.numeric(juntowol.SM[2,3]),
                                                     ifelse(행정구 %in% 서북권, as.numeric(juntowol.SM[3,3]),
                                                               ifelse(행정구 %in% 서남권, as.numeric(juntowol.SM[4,3]),
                                                                         as.numeric(juntowol.SM[5,3]))))))
```

마지막으로 앞서 언급한 식을 이용해 완전월세액을 계산해주었다. 

```{r}
# 완전월세액 계산
single.multi %<>% select(-(행정구)) %>% 
  mutate(행정구 = gu, 행정동 = dong, deposit = `보증금(만원)`,month = `월세(만원)`)  %>% 
  group_by(행정구, 행정동) %>%
  summarise(단독다가구 = n(), mean.dep = mean(deposit), mean.mon = mean(month), 
                 mean.juntowol = mean(전월세전환율),
                   total.month = mean.dep * (mean.juntowol/12) + mean.mon) %>% 
  select(행정구, 행정동, total.month, 단독다가구)
```

'신사동' 명칭 변경 역시 진행해주었다.

```{r}
single.multi[single.multi$행정구 == "관악구" & single.multi$행정동 == "신사동", "행정동"] <- "신사동_관"
single.multi[single.multi$행정구 == "강남구" & single.multi$행정동 == "신사동", "행정동"] <- "신사동_강"
```

완성된 최종 single.multi 데이터는 다음과 같다.

```{r , echo=FALSE}
single.multi %>% head()
```


#### - 아파트 전/월세 거래 데이터

전처리 과정이 위와 동일하기 때문에 자세한 설명은 생략한다.

```{r}
# 필요한 데이터만 추출
apartment %<>% filter(`전용면적(㎡)` < 40.00,도로명 != " ", 전월세구분 == '월세') %>% 
  select(도로명, 시군구, `보증금(만원)`, `월세(만원)`) %>% 
  mutate(행정구 = str_replace(시군구, '(\\w+[시]) (\\w+[구]) (\\w+[동]|\\w+[동]\\w[가]|\\w+[로]\\w[가]|\\w+[가])','\\2'),
            행정구 = str_replace(행정구, '\\d[가]', ""),
            도로명 = paste0(행정구," ", 도로명))
```

```{r , warning=FALSE}
# 검색할 주소 목록
address_list <- apartment$도로명

# 결과 저장용 데이터프레임

bowl4 = data.frame(address = address_list,
                  dong = rep(NA, length(address_list)),
                  long = rep(NA, length(address_list)),
                  lat = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){
  
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  
  if (length(coord$documents$address_type[1]) == 0) {
    # 검색 결과가 없는 경우
    bowl4$dong[i] <- NA
    bowl4$long[i] <- NA
    bowl4$lat[i] <- NA
  } else {
    # 위도와 경도를 이용한 행정동 역추적
    long <- coord$documents$x[1]
    lat <- coord$documents$y[1]
    
    res1 <- GET(url = 'https://dapi.kakao.com/v2/local/geo/coord2regioncode.json',
                query = list(x = long, y = lat),
                add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
    
    coord1 <- res1 %>% content(as = 'text') %>% fromJSON()
    
    bowl4$dong[i] <- coord1$documents$region_3depth_name[2]
    bowl4$long[i] <- coord1$documents$x[2]
    bowl4$lat[i] <- coord1$documents$y[2]
  }
}

# apartment 데이터와 합쳐주기
apartment %<>% cbind(bowl4) %>% 
  select(-c(도로명, address, 시군구)) %>% 
  drop_na() %>%  # NA는 직접 채우는 게 어렵다고 판단해 삭제
  mutate(`보증금(만원)` = as.integer(gsub(",","",`보증금(만원)`,fixed=TRUE)))
```

마찬가지로 전월세전환율 데이터를 이용해 완전월세액을 계산하고자 한다. 다만, 아파트의 경우 지역별 전월세전환율 데이터에 행정구 별로 정리되어 있기 때문에 해당 데이터를 사용한다.

```{r}
# 지역별 전환율데이터
juntowol.APT <- juntowol_area %>% filter(`지역별(1)` == '서울', `지역별(4)` != '소계', `주택유형별(1)` == '아파트') %>% 
                  select(`지역별(4)`, `2021. 01`, `2021. 02`) %>% 
                  mutate(전월세전환율 = (`2021. 01` + `2021. 02`)/2, 
                               `지역별(4)` = paste0(`지역별(4)`, '구')) %>% 
                  select(-c(`2021. 01`, `2021. 02`)) %>% 
                  rename(행정구 = `지역별(4)`)

# 기존의 apartment 데이터와 합쳐줌
apartment %<>% left_join(juntowol.APT, by = '행정구')
```

```{r}
# 완전월세액 계산
apartment %<>% 
  mutate(행정동 = dong, deposit = as.integer(`보증금(만원)`),month = as.integer(`월세(만원)`))  %>% 
  group_by(행정구, 행정동) %>%
  summarise(아파트 = n(), mean.dep = mean(deposit), mean.mon = mean(month), mean.juntowol = mean(전월세전환율),
            total.month = mean.dep * (mean.juntowol/12) + mean.mon) %>% 
  select(행정구, 행정동, total.month, 아파트)
```

완성된 apartment 데이터는 다음과 같다.

```{r , echo=FALSE}
apartment %>% head()
```


#### - 연립/다세대 주택 거래 데이터

마찬가지로 위와 동일한 전처리 과정을 진행한다.

```{r}
# 필요한 데이터만 추출
coalition %<>% filter(`전용면적(㎡)` < 40.00, 도로명 != ' ', 전월세구분 == '월세') %>% 
  select(도로명, 시군구, `보증금(만원)`, `월세(만원)`) %>% 
  mutate(행정구 = str_replace(시군구, '(\\w+[시]) (\\w+[구]) (\\w+[동]|\\w+[동]\\w[가]|\\w+[로]\\w[가]|\\w+[가])','\\2'),
            행정구 = str_replace(행정구, '\\d[가]', ""),
            도로명 = paste0(행정구," ", 도로명))
```

```{r , warning=FALSE}
# 검색할 주소 목록
address_list <- coalition$도로명

# 결과 저장용 데이터프레임

bowl5 = data.frame(address = address_list,
                  dong = rep(NA, length(address_list)),
                  long = rep(NA, length(address_list)),
                  lat = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){
  
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  if (length(coord$documents$address_type) == 0) {
    bowl5$dong[i] <- NA
    bowl5$long[i] <- NA
    bowl5$lat[i] <- NA
  } else if (coord$documents$address_type == 'ROAD'){
    bowl5$dong[i] <- NA
    bowl5$long[i] <- NA
    bowl5$lat[i] <- NA
  } else {
    dong <- coord$documents$address$region_3depth_h_name
    
    if (length(dong) > 0) {
      bowl5$dong[i] <- dong
      bowl5$long[i] <- as.double(coord$documents$x)
      bowl5$lat[i] <- as.double(coord$documents$y)
    } else {
      bowl5$dong[i] <- NA
      bowl5$long[i] <- NA
      bowl5$lat[i] <- NA
    }
  }
}

# coalition 데이터와 합쳐주기
coalition %<>% cbind(bowl5) %>% 
  select(-c(도로명, address, 시군구)) %>% 
  drop_na() %>%  # NA는 직접 채우는 게 어렵다고 판단해 삭제
  mutate(`보증금(만원)` = as.integer(gsub(",","",`보증금(만원)`,fixed=TRUE)))
```

```{r}
# 규모별 전월세전환율 데이터 사용
juntowol.CO <- juntowol_scale %>% filter(주택유형 == '연립다세대')

coalition %<>% mutate(전월세전환율 = ifelse(행정구 %in% 도심권, as.numeric(juntowol.CO[1,3]), 
                                            ifelse(행정구 %in% 동북권, as.numeric(juntowol.CO[2,3]),
                                                      ifelse(행정구 %in% 서북권, as.numeric(juntowol.CO[3,3]),
                                                                ifelse(행정구 %in% 서남권, as.numeric(juntowol.CO[4,3]),
                                                                          as.numeric(juntowol.CO[5,3]))))))
```

```{r}
# 완전월세액 게산
coalition %<>% 
  mutate(행정동 = dong, deposit = `보증금(만원)`,month = `월세(만원)`)  %>% 
  group_by(행정구, 행정동) %>%
  summarise(연립다세대 = n(), mean.dep = mean(deposit), mean.mon = mean(month), mean.juntowol = mean(전월세전환율),
            total.month = mean.dep * (mean.juntowol/12) + mean.mon) %>% 
  select(행정구, 행정동, total.month, 연립다세대)

# 신사동 명칭 변경
coalition[coalition$행정구 == "관악구" & coalition$행정동 == "신사동", "행정동"] <- "신사동_관"
coalition[coalition$행정구 == "강남구" & coalition$행정동 == "신사동", "행정동"] <- "신사동_강"
```

후에 데이터를 합치는 과정에서 문제가 발생할 수 있기 때문에 다른 데이터들과 행정동명을 맞춰주고자 '면목3.8동'의 명칭을 변경해주었다.

```{r}
coalition[coalition$행정동 == "면목3.8동","행정동"] <- "면목제3.8동"
```

완성된 coalition 데이터는 다음과 같다.

```{r , echo=FALSE}
coalition %>% head()
```


#### - 오피스텔 주택 거래 데이터

오피스텔 데이터 역시 같은 방식으로 전처리를 진행하였다.

```{r}
# 필요한 데이터 추출
officetel %<>% filter(`전용면적(㎡)` < 40.00, 도로명 != ' ', 전월세구분 == '월세') %>% 
  select(도로명, 시군구, `보증금(만원)`, `월세(만원)`) %>% 
  mutate(행정구 = str_replace(시군구, '(\\w+[시]) (\\w+[구]) (\\w+[동]|\\w+[동]\\w[가]|\\w+[로]\\w[가]|\\w+[가])','\\2'),
            행정구 = str_replace(행정구, '\\d[가]', ""),
            도로명 = paste0(행정구," ", 도로명))
```

```{r , warning=FALSE}
# 검색할 주소 목록
address_list <- officetel$도로명

# 결과 저장용 데이터프레임

bowl6 = data.frame(address = address_list,
                  dong = rep(NA, length(address_list)),
                  long = rep(NA, length(address_list)),
                  lat = rep(NA, length(address_list)))

# 주소별 반복
for(i in 1:length(address_list)){
  
  res <- GET(url = 'https://dapi.kakao.com/v2/local/search/address.json',
             query = list(query = address_list[i]),
             add_headers(Authorization = paste0("KakaoAK ", KAKAO_MAP_API_KEY)))
  
  coord <- res %>% content(as = 'text') %>% fromJSON()
  if (length(coord$documents$address_type) == 0) {
    bowl6$dong[i] <- NA
    bowl6$long[i] <- NA
    bowl6$lat[i] <- NA
  } else if (coord$documents$address_type == 'ROAD'){
    bowl6$dong[i] <- NA
    bowl6$long[i] <- NA
    bowl6$lat[i] <- NA
  } else {
    dong <- coord$documents$address$region_3depth_h_name
    
    if (length(dong) > 0) {
      bowl6$dong[i] <- dong
      bowl6$long[i] <- as.double(coord$documents$x)
      bowl6$lat[i] <- as.double(coord$documents$y)
    } else {
      bowl6$dong[i] <- NA
      bowl6$long[i] <- NA
      bowl6$lat[i] <- NA
    }
  }
}

# officetel 데이터와 합쳐주기
officetel %<>% cbind(bowl6) %>% 
  select(-c(도로명, address, 시군구)) %>% 
  drop_na() %>%  # NA는 직접 채우는 게 어렵다고 판단해 삭제
  mutate(`보증금(만원)` = as.integer(gsub(",","",`보증금(만원)`,fixed=TRUE)))
```

완전월세액 계산을 위해 규모별 전월세전환율 데이터를 사용하였다. 다만, 오피스텔의 경우 따로 전월세전환율 데이터가 없었기 때문에 오피스텔을 연립/다세대 주택으로 보고 연립/다세대 주택의 전월세전환율을 사용하였다.

```{r}
officetel %<>% mutate(전월세전환율 = ifelse(행정구 %in% 도심권, as.numeric(juntowol.CO[1,3]), 
                                         ifelse(행정구 %in% 동북권, as.numeric(juntowol.CO[2,3]),
                                                   ifelse(행정구 %in% 서북권, as.numeric(juntowol.CO[3,3]),
                                                             ifelse(행정구 %in% 서남권, as.numeric(juntowol.CO[4,3]),
                                                                       as.numeric(juntowol.CO[5,3]))))))

```

```{r}
# 완전월세액 게산
officetel %<>% 
  mutate(행정동 = dong, deposit = `보증금(만원)`,month = `월세(만원)`)  %>% 
  group_by(행정구, 행정동) %>%
  summarise(오피스텔 = n(), mean.dep = mean(deposit), mean.mon = mean(month), mean.juntowol = mean(전월세전환율),
            total.month = mean.dep * (mean.juntowol/12) + mean.mon) %>% 
  select(행정구, 행정동, total.month, 오피스텔)


# 신사동 명칭 변경
officetel[officetel$행정구 == "관악구" & officetel$행정동 == "신사동", "행정동"] <- "신사동_관"
```

완성된 officetel 데이터는 다음과 같다.

```{r , echo=FALSE}
officetel %>% head()
```

#### - 완전월세액 합치기

완전월세액, 즉 부동산 가격은 주택 유형보다는 지역에 더 영향을 많이 받는 변수이다. 따라서, 주택 유형별 4개의 변수를 모두 사용할 경우 correlation이 굉장히 높을 것이고, 주택 유형에 따라 거래 건수가 없어 완전월세액이 없는 행정동이 많다. 이를 해결하고자, 주택 유형별 완전월세액을 하나의 변수로 합치고자 한다. 이 때, 행정동 별로 각 주택 유형의 거래 건수를 계산해 전체 거래 중 해당 주택 유형의 거래 건수를 고려한 완전월세액 변수를 생성하였다.

```{r}
## 네 개의 주택 유형별 데이터 합치기
total_month <-
  single.multi %>% full_join(apartment, by = c("행정구", "행정동"), suffix = c("_단독다가구", "_아파트")) %>% 
          full_join(coalition, by = c("행정구", "행정동")) %>% 
          full_join(officetel, by = c("행정구", "행정동"), suffix = c("_연립", "_오피스텔"))

## 거래가 존재하지 않아 NA인 곳은 0으로 대체
total_month[is.na(total_month$단독다가구),"단독다가구"] <- 0
total_month[is.na(total_month$아파트),"아파트"] <- 0
total_month[is.na(total_month$연립다세대),"연립다세대"] <- 0
total_month[is.na(total_month$오피스텔),"오피스텔"] <- 0
total_month[is.na(total_month$total.month_단독다가구),"total.month_단독다가구"] <- 0
total_month[is.na(total_month$total.month_아파트),"total.month_아파트"] <- 0
total_month[is.na(total_month$total.month_연립),"total.month_연립"] <- 0
total_month[is.na(total_month$total.month_오피스텔),"total.month_오피스텔"] <- 0

## 각 주택 유형별로 '완전월세액 X 거래건수 비율'을 계산해 하나의 완전월세액을 만들어줌
total_month %<>% mutate(거래 = 단독다가구 + 아파트 + 연립다세대 + 오피스텔,
                         완전월세액 = total.month_단독다가구*단독다가구/거래 + total.month_아파트*아파트/거래 +
                           total.month_연립*연립다세대/거래 + total.month_오피스텔*오피스텔/거래) %>% 
  select(행정구, 행정동, 완전월세액)
```

이렇게 만들어진 완전월세액 변수를 시각화하면 다음과 같다.

```{r}
## 지도 데이터와 결합
mapping <- dong_code %>% left_join(total_month, by = c("시군구명" = "행정구", "행정동명" = "행정동")) %>% 
  rename(행정동코드 = 통계청행정동코드)
mapping[is.na(mapping$완전월세액), "완전월세액"] <- 0
mapping$행정동코드 %<>% as.numeric()
house_map <- mapping %>% left_join(seoul_map, by = c("행정동코드" = "id"))

## plot
ggplot() + 
  geom_polygon(data = house_map, aes(x = long, y = lat, group = group, fill = 완전월세액), color = 'lightgrey') +
  scale_fill_gradient(low = "white", high = "#965A9D") + ggtitle('부동산 가격 (완전월세액)') +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

우선 전반적으로 남동쪽 지역의 행정동들이 높은 가격을 보이는 것을 알 수 있다. 집값이 비쌀 수록 거주하는 청년들의 집값 부담이 커지는데, 특히 남동쪽의 경우 역세권 청년주택이 존재하지 않기 때문에 고려해야 하는 점으로 보인다. <br>
하지만 정책의 예산 문제도 고려하지 않을 수 없기 때문에 적당한 타협점이 필요할 것으로 보인다.


## 04. 최종 데이터

### 1) 데이터 join 및 결측치 대체

위에서 전처리한 모든 데이터들을 합쳐 하나의 데이터로 만든 후, 결측치 등을 처리하였다. <br>
우선 데이터를 합치기 전에, 각 데이터별 행정동명에 차이가 존재하므로 이를 먼저 통합시켜주었다.

```{r}
company$행정동 %>% setdiff(population$행정동)
company[company$행정동 == "종로5·6가동", "행정동"] <- "종로5.6가동"

marriage$행정동 %>% setdiff(population$행정동)
marriage[marriage$행정동 == "종로5·6가동", "행정동"] <- "종로5.6가동"

univ$행정동 %>% setdiff(population$행정동)
univ[univ$행정동 == "면목제3.8동", "행정동"] <- "면목3.8동"

traffic_closure$행정동 %>% setdiff(population$행정동)
population[population$행정동 == "종로5·6가동", "행정동"] <- "종로5.6가동"
traffic_closure[traffic_closure$행정동 == "면목제3.8동", "행정동"] <- "면목3.8동"

total_month$행정동 %>% setdiff(population$행정동)
total_month[total_month$행정동 == "면목제3.8동", "행정동"] <- "면목3.8동"
```

다음으로 425개의 모든 행정동을 포함하고 있는 population 데이터를 기준으로 left_join 하였다.

```{r}
final <- 
  population %>% left_join(company, by = c('행정동', '행정구')) %>% 
            left_join(marriage, by = c('행정동', '행정구')) %>% 
            left_join(univ, by = c('행정동', '행정구')) %>% 
            left_join(traffic_closure, by = c("행정구" = "자치구", "행정동")) %>% 
            left_join(total_month, by = c("행정구", "행정동"))
```

합친 데이터의 결측치를 확인해보면 다음과 같다.

```{r , echo=FALSE}
colSums(is.na(final))
```

우선 '종사자수', '사업체수', '대학수'의 경우 해당 행정동에 존재하지 않는다는 의미이므로 0으로 대체하였다.

```{r}
final[is.na(final$`종사자수`),"종사자수"] <- 0
final[is.na(final$`사업체수`),"사업체수"] <- 0
final[is.na(final$`대학 수`),"대학 수"] <- 0
```

다음으로 완전월세액에서의 결측치는 속한 자치구의 평균값으로 대체하였다.

```{r}
## 자치구 별 완전월세액 평균 
total.month_gu <-  final %>% group_by(행정구) %>% 
            summarise(mean = mean(완전월세액, na.rm = T))

for (i in 1:nrow(final)){
  if (is.na(final[i, "완전월세액"])){
    final[i, "완전월세액"] <- total.month_gu[total.month_gu$행정구 == as.character(final[i, "행정구"]),"mean"]
  } else next
}
```

```{r}
colSums(is.na(final))
```

결측치 대체 후, 결측치를 다시 한 번 확인해보면 전체 데이터에 결측치가 없는 것을 확인할 수 있었다. <br><br>

### 2) 행정동코드 결합 

앞서 지도 시각화를 위해 거친 과정과 마찬가지로 최종 데이터에도 행정동 코드 데이터를 결합해주었다.

```{r}
final %<>% left_join(dong_code, by = c("행정구" = "시군구명", "행정동" = "행정동명"))
final %<>% rename(행정동코드 = 통계청행정동코드)
final$행정동코드 <- as.numeric(final$행정동코드)
```

행정동코드 데이터의 행정동명 중에 final 데이터에서의 행정동명과 다른 것이 있어 수기로 변경해주었다. 또한 신사동의 명칭 역시 final 데이터에 맞추어 주었다.

```{r}
dong_code[dong_code$행정동명 == "종로5.6가동", "행정동명"] <- "종로5·6가동"
dong_code[dong_code$시군구명 == "관악구" & dong_code$행정동명 == "신사동", "행정동명"] <- "신사동_관"
dong_code[dong_code$시군구명 == "강남구" & dong_code$행정동명 == "신사동", "행정동명"] <- "신사동_강"
```

완성된 final 데이터는 다음과 같다.

```{r , echo=FALSE}
final %>% head()
```

<br>

## 05. 후보 행정동 선정

### 01) 현재 역세권 청년주택이 존재하는 행정동 제외

역세권 청년주택의 분산을 위해 현재 역세권 청년주택이 존재한느 행정동은 후보 입지에서 제외하였다. 그 결과 총 21개의 행정동이 제외되었다.

```{r}
youth_list <- 
  youthhouse %>% group_by(gu, dong) %>% summarise(청년주택 = n())

youth_list$dong %>% setdiff(final$행정동) # 행정동 이름 일치

final <- final[!(final$행정동 %in% youth_list$dong),] # 21개의 행정동 제외
```

### 02) 역이 존재하지 않는 행정동 제외

역세권 청년주택인 만큼 역이 존재하지 않는 행정동은 입지가 될 수 없다. 따라서 앞서 저장해놓은 역이 존재하지 않는 행정동 리스트를 이용해 행정동을 제거해주었다. 그 결과, 총 212개의 행정동이 제외되었다.

```{r}
final <- final[!(final$행정동 %in% no_subway$행정동),] # 212개의 행정동 제외
```

위의 과정을 거쳐 남은 행정동을 시각화해보면 다음과 같다.

```{r}
candidate_map <- final %>% left_join(seoul_map, by = c("행정동코드" = "id"))

ggplot() +
  geom_polygon(data = seoul_map, aes(x = long, y = lat, group = group), fill = "white", color = "lightgrey") +
  geom_polygon(data = candidate_map, aes(x = long, y = lat, group = group), fill = "#965A9D", color = 'lightgrey', alpha = 0.8) +
  ggtitle("클러스터링을 진행할 행정동") +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```


## 06. 클러스터링

### 01) 전처리

클러스터링에 들어가기 앞서 필요없는 변수를 삭제해주었다.

```{r}
final %<>% select(-c(`20~24세`, `25~29세`, `30~34세`, `35~39세`))
```

### 02) 필요점수 생성

상관관계가 높은 변수들이 많을 경우, 클러스터링의 성능을 크게 저하시킨다. 따라서 변수들 간의 상관관계를 확인 후, 차원 축소를 하고자 했다.

```{r}
corrplot::corrplot(cor(final[,3:9])) 
```

상관플랏을 그려본 결과 청년인구, 혼인(신혼부부 수), 사업체수, 종사자수, 교통밀접도 변수가 높은 상관관계를 보이고 있다. 이를 해결하고자 이 다섯 개의 변수들로 차원축소 방법 세 가지를 시도하였다. <br>
이 때, 차원축소를 통해 만들어진 새로운 변수를 사용하는 것이 아니라 차원축소를 통해 각 변수의 가중치를 구해 하나의 변수를 만들어주었다.

#### - PCA

PCA는 데이터의 분산이 최대가 되는 초평면에 투영 시키는 방법으로, 다시 말해 원본의 데이터셋과 투영된 데이터셋 간의 평균제곱거리를 최소화하는 방법이라고 할 수 있다. 

```{r}
pca <- prcomp(final[,c(3:6,8)], center = T, scale. = T)

summary(pca)
```

PCA 결과, 한 개의 PC로 전체 분산의 약 51%를 설명할 수 있었다.

#### - Non-negative sparse PCA

다음으로 non-negative sparse PCA를 사용하였다. 이 방법은 일반적인 PCA와 다르게 모든 PC에 대해 각 변수의 영향력이 모두 양의 값을 가진다. 

```{r}
set.seed(0)
nonneg_pca <- nsprcomp(final[,c(3:6,8)], nneg = TRUE, scale. = T, center = T)
nonneg_pca
summary(nonneg_pca)  # cumulative proprtion = 0.6409
```

Non-negative sparse PCA 결과, 한 개의 PC로 전체 분산의 약 64%를 설명할 수 있었다.

#### - Factor Analysis

마지막으로 FA(요인 분석)은 다수의 변수들에 잠재되어 있는 공통 인자를 찾아내는 방법이다. FA는 PCA와 매우 유사하지만 가장 큰 차이점은 생성된 변수들의 관계이다. PCA의 경우, 제1성분이 가장 중요하고 그 다음 제2성분 순으로 변수들 간의 중요성 순위가 존재한다. 하지만 FA의 경우, 새 변수들은 기본적으로 대등한 관계를 갖는다. <br><br>

FA를 실행하기 전에 우선 변수들 간의 scale을 맞춰 주어야 한다. scale이 다를 경우, scale이 큰 변수에만 영향을 크게 받을 수 있기 때문이다.

```{r}
## min-max scaling 함수 생성
normalize <- function(x) {
  return((x-min(x))/(max(x)-min(x)))
}

## min-max scaling 수행
final1 <- final
for (i in 3:9){
  final1[,i] <- normalize(final1[,i])
}

## FA 실행
fa <- factanal(final1[,c(3:6,8)], factors = 1, rotation="varimax")
print(fa, cutoff = 0)
```

FA 결과, 한 개의 factor로 전체 분산의 약 40%를 설명할 수 있었다. <br><br>

세 가지 차원축소 방법을 실행해본 결과, 가장 성능이 좋았던 non-negative sparse PCA를 사용하기로 하였다. 이 방법이 한 개의 변수로 전체 분산 중 가장 많은 부분을 설명할 수 있었으며, 가중치가 모두 양수이기 때문에 점수를 만드는 데 더 적합하다고 판단했다.

```{r}
## 필요점수 계산
for (i in 1:nrow(final1)){
  final1$필요점수[i] <- (normalize(rowSums(nonneg_pca$rotation[,1]*final1[,c(3:6,8)])))[i]
}
```


### 03) 클러스터링

지금까지 상관관계가 높은 5개의 변수를 non-negative sparse PCA를 이용해 **'필요점수'** 라는 하나의 변수를 만들었다. 이 때 사용되지 않은 변수에는 **'대학 수'** 와 **'완전월세액'** 이 있다. <br>
하지만 '대학 수'의 경우, 대부분의 행정동의 값이 0이고, 그 외에도 1 또는 2의 값만 갖기 때문에 클러스터링의 성능을 저하시킨다. 또한 현재 존재하는 역세권 청년주택이 대학교를 많이 고려한 듯 했기 때문에 그 외의 변수들에 중점을 두고자 '대학 수' 변수는 클러스터링에 사용하지 않았다.
<br>

```{r}
## 필요한 변수만 추출
cluster_df <- final1 %>% select(행정동, 완전월세액, 필요점수)
```

이제부터 '필요점수'와 '완전월세액', 총 두 가지 변수로 클러스터링을 진행할 것이다. 총 세 가지 방법을 사용하였는데, **1) k-means** , **2) k-medoids**, **3) hierarchical** 이다.
<br>

#### - K-means

k-means 클러스터링은 각 데이터로부터 그 데이터가 속한 클러스터의 중심까지의 평균을 최소화하는 방법으로, 가장 흔하게 사용하는 클러스터링 기법이다.
<br><br>

먼저 가장 적합한 클러스터의 개수(k)를 찾기 위해 k를 1부터 20까지로 두고 그 결과를 확인했다.

```{r}
set.seed(0)
result<-NULL
for (k in 1:20){
  result[[k]]<-kmeans(cluster_df[,c(2:3)],k)
}
```

다음으로 그래프를 통해 elbow point와 실루엣 계수를 확인해보았다.

```{r}
## 1) Elbow point  
fviz_nbclust(cluster_df[,c(2:3)], FUN=kmeans, method = "wss", k.max = 20) 

## 2) Average Silhouette
avgsil<-numeric(20)
for (k in 2:20){
  si<-summary(silhouette(result[[k]]$cluster,dist(cluster_df[,c(2:3)])))
  avgsil[k]<-si$avg.width
}
avgsil

fviz_nbclust(cluster_df[,c(2:3)], FUN=kmeans, method = "silhouette", k.max = 20) 
```

먼저, 첫 번째 그래프를 보면 눈에 띄는 elbow point는 찾을 수 없었다. <br>
다음으로 실루엣 계수 그래프와 그 값을 보면 k가 3일 때, 실루엣 계수가 0.4452로 가장 높은 것을 알 수 있다.

#### - K-medoids

K-medoids 클러스터링은 ‘PAM’ 기법으로도 불리며, k-means와 매우 유사하지만 해당 군집의 **중앙값**을 중심점으로 본다는 차이가 있다. 평균이 아닌 중앙값을 사용하기 때문에 이상치에 덜 민감하다는 장점이 있다. <br>
k-means 클러스터링과 같이 그래프와 실루엣 계수를 확인하였다.

```{r}
## 1) Elbow point
fviz_nbclust(cluster_df[,2:3], FUNcluster = pam, method='wss', k.max = 20)

## 2) Silhouette
set.seed(0)
result<-NULL
for (k in 1:20){
  result[[k]]<-pam(cluster_df[,c(2:3)],k)
}

avgsil<-numeric(20)
for (k in 2:20){
  si<-summary(silhouette(result[[k]]$cluster,dist(cluster_df[,c(2:3)])))
  avgsil[k]<-si$avg.width
}
avgsil

fviz_nbclust(cluster_df[,2:3], FUNcluster = pam, method = "silhouette", k.max = 20)
```

그 결과, k-means와 마찬가지로 눈에 띄는 elbow point는 찾을 수 없었고 실루엣 계수의 경우 k가 2일 때, 0.3983이라는 값이 가장 컸다. 

#### - Hierarchical(계층적)

계층적 클러스터링은 유사도 행렬을 이용해 개체들을 가까운 집단부터 순차적이고 계층적으로 차근차근 묶어 나가는 방식이다. 보통 k-means 등의 기법을 사용하기 전, 클러스터의 개수를 정할 때 사용하기도 한다.

```{r}
set.seed(0)
## 1) 거리 계산
res.dist <- dist(cluster_df[,2:3], method = "euclidean")

## 2) Elbow point
fviz_nbclust(cluster_df[,2:3], FUNcluster = hcut, method='wss', k.max = 20) # 유의미한 포인트 찾을 수 없음

## 3) Silhouette
plot_hc <- fviz_nbclust(cluster_df[,2:3], FUNcluster = hcut, method = "silhouette", k.max = 20) 
plot_hc
plot_hc$data$y # k = 3, 0.4222

## 4) 밴다이어그램 그리기
res.hc <- eclust(res.dist, "hclust", k = 3,
                 method = "ward.D2", graph = FALSE) 

fviz_dend(res.hc, rect = TRUE, show_labels = T, cex = 0.5,
          k_colors = c("#965A9D", "#14B9B7",  "#FFC064")) 
```

결과를 보면 우선 마찬가지로 유의미한 elbow point는 찾을 수 없다. 실루엣 계수를 보면 k가 3일 때, 0.4712라는 높은 값을 갖는 것을 알 수 있다. 하지만 벤다이어그램을 보면 클러스터간의 불균형이 매우 심각하다.
<br><br>

따라서 최종 클러스터링 모델로 k-means를 선택하였다. 실루엣 값이 0.4452로 높은 편이었으며 최적의 클러스터 개수도 3개로 적당하였다. 또한 클러스터 간의 불균형도 심하지 않았기 때문에 최종 모델로 선택되었다. <br><br>

k-means 클러스터링을 이용해 3개의 클러스터로 나눈 모습을 시각화하면 다음과 같다.

```{r}
set.seed(0)
result<-NULL
for (k in 1:20){
  result[[k]]<-kmeans(cluster_df[,c(2:3)],k)
}

fviz_cluster(result[[3]],data=cluster_df[,c(2:3)],geom="point",stand= F)
```

각 클러스터의 평균값을 살펴보면 다음과 같다.

```{r}
result[[3]]$centers
```

여기서 타겟 클러스터는 필요점수가 가장 높고 완전월세액은 중간인 **클러스터1**이다. 클러스터1의 경우, 우선 필요점수가 다른 클러스터들에 비해 매우 높은 편이므로 우선적으로 역세권 청년주택이 생겨야 한다고 볼 수 있다. 또한 완전월세액의 경우, 너무 높지 않기 때문에 예산의 문제에서 자유로우며 너무 낮지도 않아 청년들의 경제적 부담이 높은 지역이라고 할 수 있다. 


## 07. 최종 입지 선정

```{r}
result[[3]]$size[1]
```

위에서 구한 타겟 클러스터는 총 50개의 행정동을 포함하고 있다. 따라서 이 중 우선적으로 역세권 청년주택이 세워져야 할 입지를 선정해야 한다. 이 때, 필요점수를 기준으로 상위 행정동 3개를 최종 입지로 선정하였다. 

```{r}
priority <- final1 %>% filter(cluster == 1)

top3 <- priority[order(priority$필요점수, decreasing = T),] %>% head(3)
```

최종적으로 선정된 행정동 3개를 시각화해보면 다음과 같다.

```{r}
top3_map <- top3 %>% left_join(seoul_map, by = c("행정동코드" = "id"))

ggplot() +
  geom_polygon(data = seoul_map, aes(x = long, y = lat, group = group), fill = "white", color = "lightgrey") +
  geom_polygon(data = top3_map, aes(x = long, y = lat, group = group), fill = "#14B9B7", color = 'lightgrey') +
  ggtitle("위험도지수 상위 3개 행정동") +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold")) +
  labs(fill = " ")
```

최종 입지로 선정된 행정동은 **'가산동'**, **'역삼1동'**, **'가양1동'** 이다. 선정된 행정동 내에 존재하는 전철역을 시각화하여, 현재 존재하는 역세권 청년주택의 위치와 비교해보았다.

```{r}
## 최종 입지 행정동 내의 전철역
subway <- fread("지하철_행정동추가.csv")

final_station <- subway %>% filter(dong == "가산동" | dong == "역삼1동" | dong == "가양1동")

## plot
ggplot() +
  geom_polygon(data = seoul_map, aes(x = long, y = lat, group = group), fill = "white", color = "lightgrey") +
  geom_point(data = youthhouse,aes(x = long, y = lat), color = "#965A9D", alpha = 0.55,  size = 3) +
  geom_point(data = final_station, aes(x = x, y = y), color = "#14B9B7", alpha = 0.55, size = 3) +
  ggtitle("현재 존재하는 청년주택 위치 및 후보지 3곳의 지하철역 위치") +
  theme(panel.background = element_rect(fill='white', color='white'),
        plot.title = element_text(size = 20, face = "bold", family = "nanum"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        strip.background = element_rect(fill="white", color="darkgrey"),
        legend.title=element_text(size=10),
        strip.text = element_text(face="bold"))
```

시각화 결과를 보면, 역삼1동의 경우 기존에 부족하던 남동쪽 지역을 잘 보완할 수 있을 것으로 보인다. 또한 역삼1동에는 3개의 역이 존재해 입지가 될 수 있는 건물의 선택지도 매우 넓을 것이며, 사람들의 수요 또한 많을 것으로 예상된다. <br>
가양1동 역시 현재 존재하는 역세권 청년주택과 어느 정도 거리를 유지하는 곳이며, 수도권과 가까워 서울 뿐만 아니라 수도권에 위치한 대학 및 회사와의 접근성 역시 좋을 것으로 생각된다. <br>
반면, 가산동의 경우 이미 존재하는 역세권 청년주택과 매우 인접한 지역이다. 이는 입지 선정 과정에서 현재 역세권 청년주택이 존재하는 행정동만 제외했을 뿐, 그 거리까지는 미처 고려하지 못했기 때문이다. 하지만 이번 분석을 통해 선정된 입지가 실제 역세권 청년주택의 위치와 유사하다는 점에서, 이 분석 과정이 실제 역세권 청년주택의 입지 선정 과정과 유사하다고 생각할 수 있다. 따라서 현재 존재하는 역세권 청년주택과의 거리, 역의 모든 출구 등을 고려하여 분석을 심화시킨다면 더 좋은 결과를 얻을 수 있을 것이라고 생각한다.